/*
Twilio Phone Number
		+19377708795

	Twilio Verification Code
		AmIVpa8__YUyI8brbg_M0KK_-BtLbGG-EpWSbXxg


	Regular Expressions

	Phone Number:

		All						-		/^[+]*[(]{0,1}[0-9]{1,4}[)]{0,1}[-\s\./0-9]*$/g
		9999999999				-		/\d{10}/g
		(999) 999-9999			-


	State:

		CO						-		/\b\w{2}\b/g
		Denver, CO				-		/([A-Za-z]+(?: [A-Za-z]+)*),? ([A-Za-z]{2})/g


	Zip Code:

		All						-		/^\d{5}(?:[-\s]\d{4})?$/g
		11111					-		/\b\d{5}\b/g


	Latitude Longitude

		All						-		^[-+]?([1-8]?\d(\.\d+)?|90(\.0+)?),\s*[-+]?(180(\.0+)?|((1[0-7]\d)|([1-9]?\d))(\.\d+)?)$
*/

	// handleRequests()

	if len(os.Args) == 1 {
		fmt.Println("No message included")
		os.Exit(1)
	}

	message := strings.Join(os.Args[1:], " ")
	fmt.Println(message)
	var config configurationData

	abspath, _ := filepath.Abs("config.json")
	jsonFile, err := os.Open(abspath)

	if err != nil {
		fmt.Println("Config file does not exist")
		os.Exit(1)
	}

	defer jsonFile.Close()

	data, _ := ioutil.ReadAll(jsonFile)

	json.Unmarshal(data, &config)

	choice := validate(message)
	fmt.Println(choice)

	rep := fmt.Sprintf("%v?%v=%v&per_page=3&sort=name:desc", openBreweryDB_repository, choice, strings.ReplaceAll(strings.ToLower(message), " ", "_"))
	fmt.Println(rep)
	response, err := http.Get(rep)

	//from := config.From
	//to := config.To
	//accountSid = config.AccountSID
	//authToken := config.AuthToken

	//resp, err := http.Get(openBreweryDB_repository)


/*
	Query all breweries (maximum of 50 breweries)
*/
func AllBreweries(w http.ResponseWriter, r *http.Request) {
	var Breweries []Brewery
	if r.URL.Path != "/all" {
		http.Error(w, "404 not found", http.StatusNotFound)
		return
	}

	if r.Method != "GET" {
		http.Error(w, "Method is not supported", http.StatusNotFound)
		return
	}
	
	response, err := http.Get(fmt.Sprintf("%v?per_page=5", openBreweryDB_repository))
	if err != nil {
		log.Fatal(err)
		return
	}

	defer response.Body.Close()

	err = json.NewDecoder(response.Body).Decode(&Breweries)

	if err != nil {
		panic(err)
	}
	breweryJson, err := json.Marshal(Breweries)

	if err != nil {
		panic(err)
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)

	w.Write(breweryJson)

	// body, err := ioutil.ReadAll(resp.Body)

	// if err != nil {
	// 	log.Fatal(err)
	// }

	// fmt.Fprintf(w, string(body))
}


	// body, err := ioutil.ReadAll(response.Body)

	// if err != nil {
	// 	log.Fatal(err)
	// }

	// fmt.Fprintf(w, string(body))

    
const axios = require('axios');
const qs = require('qs');

exports.handler = async (context, event, callback) => {
  // Create a new message response object
  const twiml = new Twilio.twiml.MessagingResponse();

  // Just for this example, we'll use the first digit of the incoming phone
  // number to identify the call. You'll want to use a more robust mechanism
  // for your own Functions, such as the full phone number.
  const postId = event.From[1];

  // Since we're making multiple requests, we'll create an instance of axios
  // that includes our API's base URL and any custom headers we might want to
  // send with each request. This will simply our GET and POST request paths.
  // JSONPlaceholder is a fake REST API that you can use for testing and prototyping
  const instance = axios.create({
    baseURL: 'https://jsonplaceholder.typicode.com',
    headers: { 'X-Custom-Header': 'Twilio' },
  });

  try {
    // Get the post based on the derived postId
    // If the postId was 1, this is effectively making a GET request to:
    // https://jsonplaceholder.typicode.com/posts/1
    const { data: post } = await instance.get(`/posts/${postId}`);

    const newCount = (post.messageCount || 0) + 1;

    // Like before, we're merging the new count and message into the
    // existing post object
    // In order to send this data in the application/x-www-form-urlencoded
    // format, the payload must be encoded via a utility such as qs
    const data = qs.stringify({
      ...post,
      messageCount: newCount,
      latestMessage: event.Body,
    });

    // Use a POST request to "save" the update to the API
    const update = await instance.post('/posts/', data);

    console.log(update.data);

    // Add a message to the response to let the user know that everything worked
    twiml.message(
      `Message received! This was message ${newCount} from your phone number. ðŸŽ‰`
    );
    return callback(null, twiml);
  } catch (error) {
    // As always with async functions, you need to be sure to handle errors
    console.error(error);
    // Add a message to the response to let the user know that something went wrong
    twiml.message(`We received your message, but something went wrong ðŸ˜­`);
    return callback(error);
  }
};